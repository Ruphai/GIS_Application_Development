# -*- coding: utf-8 -*-

"""
/***************************************************************************
 Landscape Metrics
                                 A QGIS plugin
 This tool summarises the size of different classes per polygon
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2021-07-19
        copyright            : (C) 2021 by Lydia Letaru & Rufai Balogun
        email                : lydia.letaru@stud.sbg.ac.at
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

__author__ = 'Lydia Letaru & Rufai Balogun'
__date__ = '2021-07-19'
__copyright__ = '(C) 2021 by Lydia Letaru & Rufai Balogun'



__revision__ = '$Format:%H$'

from qgis.PyQt.QtCore import QCoreApplication
from qgis.core import (QgsProcessing,
                       QgsFeatureSink,
                       QgsProcessingAlgorithm,
                       QgsProcessingParameterFeatureSource,
                       QgsProcessingParameterFileDestination,
                       QgsProcessingParameterField,
                       QgsProcessingParameterFeatureSink)
from qgis import processing


class LandscapeMatrixAlgorithm(QgsProcessingAlgorithm):
    """
    All Processing algorithms should extend the QgsProcessingAlgorithm
    class.
    """

    # Constants used to refer to parameters and outputs. They will be
    # used when calling the algorithm from another algorithm, or when
    # calling from the QGIS console.

    OUTPUT = 'OUTPUT'
    OUTPUT_CLIP = 'OUTPUT_CLIP'
    FIELD = 'FIELD'
    INPUT = 'INPUTFILE'
    GEOMETRY = 'GEOMETRY'

    def initAlgorithm(self, config):
        """
        Here we define the inputs and output of the algorithm, along
        with some other properties.
        """

        # We add the input vector features source. It can have any kind of
        # geometry.
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.INPUT,
                self.tr('Input layer'),
                [QgsProcessing.TypeVectorAnyGeometry]
            )
        )

        # spatial extent
        self.addParameter(
            QgsProcessingParameterFeatureSource(
                self.GEOMETRY,
                self.tr('Geometry Dataset'),
                [QgsProcessing.TypeVector]
            )
        )
        self.addParameter(QgsProcessingParameterFeatureSink(
            self.OUTPUT_CLIP, "Output Clip"))
        self.addParameter(QgsProcessingParameterField(self.FIELD,
        self.tr('Selection attribute')))

        # Output file
        self.addParameter(
            QgsProcessingParameterFileDestination(
                self.OUTPUT,
                self.tr('Output File'),
                'CSV files (*.csv)',
            )
        )

    def processAlgorithm(self, parameters, context, feedback):
        """
        Here is where the processing itself takes place.
        """

        source = self.parameterAsSource(parameters, self.INPUT, context)
        csv = self.parameterAsFileOutput(parameters, self.OUTPUT,context)
        fieldName = self.parameterAsString(parameters, self.FIELD, context)

        fields = layer.fields()

#clip the input dataset to admin boundary of choice
        selectedArea = processing.run( "native:extractbyextent",
        {'INPUT': parameters[self.INPUT],
        'EXTENT': parameters[self.GEOMETRY],
        'CLIP': bool,
        'OUTPUT' : parameters[self.OUTPUT_CLIP]},
        context=context, feedback=feedback, is_child_algorithm=True)

        # Compute the number of steps to display within the progress bar and
        # get features from source
        total = 100.0 / source.featureCount() if source.featureCount() else 0
        features = source.getFeatures()

        for current, feature in enumerate(features):
            # Stop the algorithm if cancel button has been clicked
            if feedback.isCanceled():
                break




            # Update the progress bar
            feedback.setProgress(int(current * total))

        # Return the results of the algorithm. In this case our only result is
        # the feature sink which contains the processed features, but some
        # algorithms may return multiple feature sinks, calculated numeric
        # statistics, etc. These should all be included in the returned
        # dictionary, with keys matching the feature corresponding parameter
        # or output names.
        return {self.OUTPUT: csv}

    def name(self):
        """
        Returns the algorithm name, used for identifying the algorithm.
        """
        return 'LandscapeMatrix'

    def displayName(self):
        """
        Returns the translated algorithm name, which is used for any
        user-visible display of the algorithm name.
        """
        return self.tr(self.name())

    def group(self):
        """
        Returns the name of the group this algorithm belongs to. This string is be localised.
        """
        return self.tr(self.groupId())

    def groupId(self):
        """
        Returns the unique ID of the group this algorithm belongs to.
        """
        return ''

    def tr(self, string):
        return QCoreApplication.translate('Processing', string)

    def createInstance(self):
        return LandscapeMatrixAlgorithm()
